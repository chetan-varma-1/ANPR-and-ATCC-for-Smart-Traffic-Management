import cv2 
import numpy as np 
from skimage.filters import threshold_local 
import tensorflow as tf 
from skimage import measure 
import imutils 
import os 
import pymysql

def sort_cont(character_contours): 
	""" 
	To sort contours 
	"""
	i = 0
	boundingBoxes = [cv2.boundingRect(c) for c in character_contours] 
	
	(character_contours, boundingBoxes) = zip(*sorted(zip(character_contours, 
														boundingBoxes), 
													key = lambda b: b[1][i], 
													reverse = False)) 
	
	return character_contours 


def segment_chars(plate_img, fixed_width): 
	
	""" 
	extract Value channel from the HSV format 
	of image and apply adaptive thresholding 
	to reveal the characters on the license plate 
	"""
	V = cv2.split(cv2.cvtColor(plate_img, cv2.COLOR_BGR2HSV))[2] 

	thresh = cv2.adaptiveThreshold(V, 255, 
								cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
								cv2.THRESH_BINARY, 
								11, 2) 
	
	thresh = cv2.bitwise_not(thresh) 

	
	plate_img = imutils.resize(plate_img, width = fixed_width) 
	thresh = imutils.resize(thresh, width = fixed_width) 
	bgr_thresh = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR) 

	
	labels = measure.label(thresh, background = 0) 

	charCandidates = np.zeros(thresh.shape, dtype ='uint8') 

	 
	characters = [] 
	for label in np.unique(labels): 
		
		
		if label == 0: 
			continue
		
		labelMask = np.zeros(thresh.shape, dtype ='uint8') 
		labelMask[labels == label] = 255
		cnts=cv2.findContours(labelMask,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
		cnts=cnts[1] if imutils.is_cv3() else cnts[0]
		if len(cnts)> 0:
			c=max(cnts,key=cv2.contourArea)
			(boxX,boxY,boxW,boxH)=cv2.boundingRect(c)
			aspectRatio=boxW/ float(boxH)
			solidity=cv2.contourArea(c)/float(boxW*boxH)
			heightRatio=boxH/float(plate_img.shape[0])
			keepAspectRatio= aspectRatio<1.0
			keepSolidity=solidity>0.15
			keepHeight= heightRatio > 0.5 and heightRatio < 0.95
			
			